function next_interactive_divider(){const getLastValue=(str)=>{if(typeof str!=='string')return str;const values=str.split(' ').filter(Boolean);return values[values.length-1]||str};document.querySelectorAll(".next-interactive-divider").forEach((interactive_divider)=>{const container=interactive_divider;const box=interactive_divider.querySelector(".next-interactive-divider__box");const svg=interactive_divider.querySelector(".next-interactive-divider__svg");const path=interactive_divider.querySelector(".next-interactive-divider__path");var bendIntensity=getLastValue(interactive_divider.getAttribute("data-bend-intensity"));let progress=0;let x=0.5;let time=Math.PI/2;let reqId=null;let maxBendIntensity=parseFloat(bendIntensity);const setPath=(progress)=>{const width=container.clientWidth;const midY=svg.clientHeight/2;path.setAttribute("d",`M0 ${midY} Q${width * x} ${midY + progress}, ${width} ${midY}`)};const lerp=(x,y,a)=>x*(1-a)+y*a;const manageMouseEnter=()=>{if(reqId){cancelAnimationFrame(reqId);resetAnimation()}};const manageMouseMove=(e)=>{const{movementY,clientX}=e;const pathBound=path.getBoundingClientRect();x=(clientX-pathBound.left)/pathBound.width;progress+=(movementY*maxBendIntensity)/100;setPath(progress)};const manageMouseLeave=()=>{animateOut()};const animateOut=()=>{const newProgress=progress*Math.sin(time);progress=lerp(progress,0,0.025);time+=0.2;setPath(newProgress);if(Math.abs(progress)>0.75){reqId=requestAnimationFrame(animateOut)}else{resetAnimation()}};const resetAnimation=()=>{time=Math.PI/2;progress=0;setPath(progress)};box.addEventListener("mouseenter",manageMouseEnter);box.addEventListener("mousemove",manageMouseMove);box.addEventListener("mouseleave",manageMouseLeave);setPath(progress)})}
document.addEventListener("DOMContentLoaded",function(t){bricksIsFrontend&&next_interactive_divider()})