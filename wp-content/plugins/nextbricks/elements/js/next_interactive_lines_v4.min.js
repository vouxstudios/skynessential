function next_interactive_lines_v4(){class Grad{constructor(x,y,z){this.x=x;this.y=y;this.z=z}
dot2(x,y){return this.x*x+this.y*y}}
class Noise{constructor(seed=0){this.grad3=[new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];this.p=[...Array(256).keys()];this.perm=new Array(512);this.gradP=new Array(512);this.seed(seed)}
seed(seed){if(seed>0&&seed<1)seed*=65536;seed=Math.floor(seed);if(seed<256)seed|=seed<<8;for(let i=0;i<256;i++){let v=(i&1)?(this.p[i]^(seed&255)):(this.p[i]^((seed>>8)&255));this.perm[i]=this.perm[i+256]=v;this.gradP[i]=this.gradP[i+256]=this.grad3[v%12]}}
fade(t){return t*t*t*(t*(t*6-15)+10)}
lerp(a,b,t){return(1-t)*a+t*b}
perlin2(x,y){let X=Math.floor(x),Y=Math.floor(y);x-=X;y-=Y;X&=255;Y&=255;const n00=this.gradP[X+this.perm[Y]].dot2(x,y);const n01=this.gradP[X+this.perm[Y+1]].dot2(x,y-1);const n10=this.gradP[X+1+this.perm[Y]].dot2(x-1,y);const n11=this.gradP[X+1+this.perm[Y+1]].dot2(x-1,y-1);const u=this.fade(x);return this.lerp(this.lerp(n00,n10,u),this.lerp(n01,n11,u),this.fade(y))}}
var isBricks=window.location.href.includes("brickspreview");document.querySelectorAll('.nb-interactive-lines-v4').forEach(container=>{if(isBricks){return}
const canvas=container.querySelector(".nb-interactive-lines-v4__canvas");const ctx=canvas.getContext("2d");const noise=new Noise(Math.random());let lines=[];const config={lineColor:getComputedStyle(container).getPropertyValue('--line-color').trim(),waveSpeedX:parseFloat(container.getAttribute("data-wave-speed-x")),waveSpeedY:parseFloat(container.getAttribute("data-wave-speed-y")),waveAmpX:parseFloat(container.getAttribute("data-wave-amp-x")),waveAmpY:parseFloat(container.getAttribute("data-wave-amp-y")),xGap:parseFloat(container.getAttribute("data-x-gap")),yGap:parseFloat(container.getAttribute("data-y-gap")),friction:parseFloat(container.getAttribute("data-friction")),tension:parseFloat(container.getAttribute("data-tension")),maxCursorMove:parseFloat(container.getAttribute("data-max-cursor-move"))};const mouse={x:-10,y:0,lx:0,ly:0,sx:0,sy:0,v:0,vs:0,a:0,set:!1};function resize(){canvas.width=container.clientWidth;canvas.height=container.clientHeight;setLines()}
function setLines(){lines=[];const width=canvas.width;const height=canvas.height;const totalLines=Math.ceil((width+200)/config.xGap);const totalPoints=Math.ceil((height+30)/config.yGap);const xStart=(width-config.xGap*totalLines)/2;const yStart=(height-config.yGap*totalPoints)/2;for(let i=0;i<=totalLines;i++){const pts=[];for(let j=0;j<=totalPoints;j++){pts.push({x:xStart+config.xGap*i,y:yStart+config.yGap*j,wave:{x:0,y:0},cursor:{x:0,y:0,vx:0,vy:0}})}
lines.push(pts)}}
function updateMouse(x,y){mouse.x=x;mouse.y=y;if(!mouse.set){mouse.sx=x;mouse.sy=y;mouse.lx=x;mouse.ly=y;mouse.set=!0}}
function movePoints(time){lines.forEach((pts)=>{pts.forEach((p)=>{const move=noise.perlin2((p.x+time*config.waveSpeedX)*0.002,(p.y+time*config.waveSpeedY)*0.0015)*12;p.wave.x=Math.cos(move)*config.waveAmpX;p.wave.y=Math.sin(move)*config.waveAmpY;const dx=p.x-mouse.sx,dy=p.y-mouse.sy;const dist=Math.hypot(dx,dy),l=Math.max(175,mouse.vs);if(dist<l){const s=1-dist/l;const f=Math.cos(dist*0.001)*s;p.cursor.vx+=Math.cos(mouse.a)*f*l*mouse.vs*0.00065;p.cursor.vy+=Math.sin(mouse.a)*f*l*mouse.vs*0.00065}
p.cursor.vx+=(0-p.cursor.x)*config.tension;p.cursor.vy+=(0-p.cursor.y)*config.tension;p.cursor.vx*=config.friction;p.cursor.vy*=config.friction;p.cursor.x+=p.cursor.vx*2;p.cursor.y+=p.cursor.vy*2;p.cursor.x=Math.min(config.maxCursorMove,Math.max(-config.maxCursorMove,p.cursor.x));p.cursor.y=Math.min(config.maxCursorMove,Math.max(-config.maxCursorMove,p.cursor.y))})})}
function moved(p,cursor=!0){return{x:Math.round((p.x+p.wave.x+(cursor?p.cursor.x:0))*10)/10,y:Math.round((p.y+p.wave.y+(cursor?p.cursor.y:0))*10)/10}}
function drawLines(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.beginPath();ctx.strokeStyle=config.lineColor;lines.forEach((points)=>{let p1=moved(points[0],!1);ctx.moveTo(p1.x,p1.y);points.forEach((p,idx)=>{let p2=moved(p);ctx.lineTo(p2.x,p2.y)})});ctx.stroke()}
function animate(time){mouse.sx+=(mouse.x-mouse.sx)*0.1;mouse.sy+=(mouse.y-mouse.sy)*0.1;const dx=mouse.x-mouse.lx;const dy=mouse.y-mouse.ly;const d=Math.hypot(dx,dy);mouse.v=d;mouse.vs+=(d-mouse.vs)*0.1;mouse.vs=Math.min(100,mouse.vs);mouse.lx=mouse.x;mouse.ly=mouse.y;mouse.a=Math.atan2(dy,dx);movePoints(time);drawLines();requestAnimationFrame(animate)}
container.addEventListener("mousemove",(e)=>{const rect=canvas.getBoundingClientRect();updateMouse(e.clientX-rect.left,e.clientY-rect.top)});container.addEventListener("touchmove",(e)=>{const touch=e.touches[0];const rect=canvas.getBoundingClientRect();updateMouse(touch.clientX-rect.left,touch.clientY-rect.top)},{passive:!1});window.addEventListener('resize',resize);resize();animate(0)})}
document.addEventListener("DOMContentLoaded",function(t){bricksIsFrontend&&next_interactive_lines_v4()})